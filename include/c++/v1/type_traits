// This file is part of Metallic, a runtime library for WebAssembly.
//
// Copyright (C) 2017 Chen-Pang He <chen.pang.he@jdh8.org>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/

#ifndef _METALLIC_TYPE_TRAITS
#define _METALLIC_TYPE_TRAITS

namespace std {

template<typename _T, _T __v>
struct integral_constant
{
    typedef integral_constant type;
    typedef _T value_type;

    static constexpr _T value = __v;

    constexpr operator value_type() const { return value; }

#if __cplusplus >= 201402L
    constexpr value_type operator()() const { return value; }
#endif
};

template<typename _T, _T __v>
constexpr _T integral_constant<_T, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template<typename, typename> struct is_same : false_type {};
template<typename _T> struct is_same<_T, _T> : true_type {};

template<typename _T> struct add_const { typedef const _T type; };
template<typename _T> struct add_volatile { typedef volatile _T type; };
template<typename _T> struct add_cv { typedef const volatile _T type; };

template<typename _T> struct remove_const { typedef _T type; };
template<typename _T> struct remove_const<const _T> { typedef _T type; };

template<typename _T> struct remove_volatile { typedef _T type; };
template<typename _T> struct remove_volatile<volatile _T> { typedef _T type; };

template<typename _T> struct remove_cv : remove_volatile<remove_const<_T>> {};

template<typename _T> struct remove_reference { typedef _T type; };
template<typename _T> struct remove_reference<_T&> { typedef _T type; };
template<typename _T> struct remove_reference<_T&&> { typedef _T type; };

template<typename _T> struct add_lvalue_reference
{ typedef typename remove_reference<_T>::type& type; };

template<typename _T> struct add_rvalue_reference
{ typedef typename remove_reference<_T>::type&& type; };

template<typename _T>
typename add_rvalue_reference<_T>::type declval() noexcept;

template<typename _T> struct add_pointer
{ typedef typename remove_reference<_T>::type* type; };

template<typename _T> struct remove_pointer { typedef _T type; };
template<typename _T> struct remove_pointer<_T*> { typedef _T type; };
template<typename _T> struct remove_pointer<_T* const> { typedef _T type; };
template<typename _T> struct remove_pointer<_T* volatile> { typedef _T type; };
template<typename _T> struct remove_pointer<_T* const volatile> { typedef _T type; };

typedef __SIZE_TYPE__ size_t;

template<typename _T> struct remove_extent { typedef _T type; };
template<typename _T> struct remove_extent<_T[]> { typedef _T type; };
template<typename _T, size_t _N> struct remove_extent<_T[_N]> { typedef _T type; };

template<typename _T> struct remove_all_extents { typedef _T type; };
template<typename _T> struct remove_all_extents<_T[]> : remove_all_extents<_T> {};
template<typename _T, size_t _N> struct remove_all_extents<_T[_N]> : remove_all_extents<_T> {};

template<typename _T> struct make_signed { typedef _T type; };
template<> struct make_signed<bool>;
template<> struct make_signed<char> { typedef signed char type; };
template<> struct make_signed<unsigned char> { typedef signed char type; };
template<> struct make_signed<unsigned short> { typedef short type; };
template<> struct make_signed<unsigned> { typedef int type; };
template<> struct make_signed<unsigned long> { typedef long type; };
template<> struct make_signed<unsigned long long> { typedef long long type; };

template<typename _T> struct make_unsigned { typedef _T type; };
template<> struct make_unsigned<bool>;
template<> struct make_unsigned<char> { typedef unsigned char type; };
template<> struct make_unsigned<signed char> { typedef unsigned char type; };
template<> struct make_unsigned<short> { typedef unsigned short type; };
template<> struct make_unsigned<int> { typedef unsigned type; };
template<> struct make_unsigned<long> { typedef unsigned long type; };
template<> struct make_unsigned<long long> { typedef unsigned long long type; };

#ifdef __SIZEOF_INT128__
template<> struct make_signed<unsigned __int128> { typedef __int128 type; };
template<> struct make_unsigned<__int128> { typedef unsigned __int128 type; };
#endif

template<typename _T> struct is_void : is_same<typename remove_cv<_T>::type, void> {};

template<typename _T> struct is_integral
  : integral_constant<bool, !is_same<typename make_signed<_T>::type, typename make_unsigned<_T>::type>::value>
{};

template<> struct is_integral<bool> : true_type {};

template<typename> struct is_floating_point : false_type {};
template<> struct is_floating_point<float> : true_type {};
template<> struct is_floating_point<double> : true_type {};
template<> struct is_floating_point<long double> : true_type {};

template<typename> struct is_array : false_type {};
template<typename _T> struct is_array<_T[]> : true_type {};
template<typename _T, size_t _N> struct is_array<_T[_N]> : true_type {};

template<typename _T> struct is_enum : integral_constant<bool, __is_enum(_T)> {};
template<typename _T> struct is_union : integral_constant<bool, __is_union(_T)> {};
template<typename _T> struct is_class : integral_constant<bool, __is_class(_T)> {};

template<typename> struct __is_function_helper : false_type {};
template<typename _R, typename..._Args> struct __is_function_helper<_R(_Args...)> : true_type {};
template<typename _R, typename..._Args> struct __is_function_helper<_R(_Args..., ...)> : true_type {};

template<typename _T> struct is_function
  : __is_function_helper<typename remove_cv<typename remove_reference<_T>::type>::type>
{};

template<typename> struct is_lvalue_reference : false_type {};
template<typename _T> struct is_lvalue_reference<_T&> : true_type {};

template<typename> struct is_rvalue_reference : false_type {};
template<typename _T> struct is_rvalue_reference<_T&&> : true_type {};

template<typename> struct is_reference : false_type {};
template<typename _T> struct is_reference<_T&> : true_type {};
template<typename _T> struct is_reference<_T&&> : true_type {};

template<typename> struct is_pointer : false_type {};
template<typename _T> struct is_pointer<_T*> : true_type {};
template<typename _T> struct is_pointer<_T* const> : true_type {};
template<typename _T> struct is_pointer<_T* volatile> : true_type {};
template<typename _T> struct is_pointer<_T* const volatile> : true_type {};

template<typename> struct is_member_pointer : false_type {};
template<typename _T, class _U> struct is_member_pointer<_T _U::*> : true_type {};
template<typename _T, class _U> struct is_member_pointer<_T _U::* const> : true_type {};
template<typename _T, class _U> struct is_member_pointer<_T _U::* volatile> : true_type {};
template<typename _T, class _U> struct is_member_pointer<_T _U::* const volatile> : true_type {};

template<typename _T> struct is_member_function_pointer
  : integral_constant<bool, is_member_pointer<_T>::value && is_function<_T>::value>
{};

template<typename _T> struct is_member_object_pointer
  : integral_constant<bool, is_member_pointer<_T>::value && !is_function<_T>::value>
{};

template<typename _T> struct is_arithmetic
  : integral_constant<bool, is_integral<_T>::value || is_floating_point<_T>::value>
{};

template<typename _T> struct is_fundamental
  : integral_constant<bool, is_arithmetic<_T>::value || is_void<_T>::value>
{};

template<> struct is_fundamental<decltype(nullptr)> : true_type {};
template<> struct is_fundamental<const decltype(nullptr)> : true_type {};
template<> struct is_fundamental<volatile decltype(nullptr)> : true_type {};
template<> struct is_fundamental<const volatile decltype(nullptr)> : true_type {};

template<typename _T> struct is_scalar
  : integral_constant<bool, is_arithmetic<_T>::value || is_enum<_T>::value || is_pointer<_T>::value || is_member_pointer<_T>::value>
{};

template<> struct is_scalar<decltype(nullptr)> : true_type {};
template<> struct is_scalar<const decltype(nullptr)> : true_type {};
template<> struct is_scalar<volatile decltype(nullptr)> : true_type {};
template<> struct is_scalar<const volatile decltype(nullptr)> : true_type {};

template<typename _T> struct is_object
  : integral_constant<bool, !(is_void<_T>::value || is_function<_T>::value || is_reference<_T>::value)>
{};

template<typename _T> struct is_compound
  : integral_constant<bool, !is_fundamental<_T>::value>
{};

template<typename> struct is_const : false_type {};
template<typename _T> struct is_const<const _T> : true_type {};

template<typename> struct is_volatile : false_type {};
template<typename _T> struct is_volatile<volatile _T> : true_type {};

template<typename _T> struct is_trivial
  : integral_constant<bool, __is_trivial(_T)>
{};

template<typename _T> struct is_trivially_copyable
  : integral_constant<bool, __is_trivially_copyable(_T)>
{};

template<typename _T> struct is_standard_layout
  : integral_constant<bool, __is_standard_layout(_T)>
{};

template<typename _T> struct is_pod
  : integral_constant<bool, __is_pod(_T)>
{};

template<typename _T> struct is_literal_type
  : integral_constant<bool, __is_literal_type(_T)>
{};

template<typename _T> struct is_empty
  : integral_constant<bool, __is_empty(_T)>
{};

template<typename _T> struct is_polymorphic
  : integral_constant<bool, __is_polymorphic(_T)>
{};

template<typename _T> struct is_abstract
  : integral_constant<bool, __is_abstract(_T)>
{};

template<typename _T, bool = is_arithmetic<_T>::value>
struct __is_signed_helper : false_type
{};

template<typename _T>
struct __is_signed_helper<_T, true> : integral_constant<bool, _T(-1) < _T(0)>
{};

template<typename _T> struct is_signed: __is_signed_helper<_T> {};

template<typename _T, bool = is_arithmetic<_T>::value>
struct __is_unsigned_helper : false_type
{};

template<typename _T>
struct __is_unsigned_helper<_T, true> : integral_constant<bool, _T(0) < _T(-1)>
{};

template<typename _T> struct is_unsigned: __is_unsigned_helper<_T> {};

template<typename _Base, typename _Derived>
struct is_base_of : integral_constant<bool, __is_base_of(_Base, _Derived)>
{};

template<typename _From, typename _To, bool = is_void<_From>::value || is_function<_To>::value || is_array<_To>::value>
struct __is_convertible_helper
{ typedef typename is_void<_To>::type type; };

template<typename _From, typename _To>
struct __is_convertible_helper<_From, _To, false>
{
  private:
    template<typename _T> static void __convert(_T);

    template<typename _T, typename = decltype(__convert<_T>(declval<_From>()))>
    static true_type __test(_From);

    template<typename>
    static false_type __test(...);

  public:
    typedef decltype(__test<_To>(declval<_From>())) type;
};

template<typename _From, typename _To>
struct is_convertible : __is_convertible_helper<_From, _To>::type
{};

template<size_t _Length, size_t _Alignment>
struct aligned_storage
{
    class type { alignas(_Alignment) unsigned char __data[_Length]; };
};

} // namespace std

#endif // <type_traits>

// vim: ft=cpp
