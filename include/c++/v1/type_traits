// This file is part of Metallic, a runtime library for WebAssembly.
//
// Copyright (C) 2017 Chen-Pang He <chen.pang.he@jdh8.org>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/

#ifndef _METALLIC_TYPE_TRAITS
#define _METALLIC_TYPE_TRAITS

namespace std {

////////////////////////// Integral constant ///////////////////////////

template<typename _T, _T __v>
struct integral_constant
{
    typedef integral_constant type;
    typedef _T value_type;

    static constexpr _T value = __v;

    constexpr operator value_type() const { return value; }

#if __cplusplus >= 201402L
    constexpr value_type operator()() const { return value; }
#endif
};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

///////////////////////////// Conditionals /////////////////////////////

template<bool, typename = void>
struct enable_if
{};

template<typename _T>
struct enable_if<true, _T>
{
    typedef _T type;
};

template<bool, typename _T, typename _F>
struct conditional
{
    typedef _T type;
};

template<typename _T, typename _F>
struct conditional<false, _T, _F>
{
    typedef _F type;
};

///////////////////////// Type transformations /////////////////////////

typedef __SIZE_TYPE__ size_t;

template<typename _T>
struct add_const
{
    typedef const _T type;
};

template<typename _T>
struct add_volatile
{
    typedef volatile _T type;
};

template<typename _T>
struct add_cv
{
    typedef const volatile _T type;
};

template<typename _T>
struct remove_const
{
    typedef _T type;
};

template<typename _T>
struct remove_const<const _T>
{
    typedef _T type;
};

template<typename _T>
struct remove_volatile
{
    typedef _T type;
};

template<typename _T>
struct remove_volatile<volatile _T>
{
    typedef _T type;
};

template<typename _T>
struct remove_cv
  : remove_volatile<typename remove_const<_T>::type>
{};

template<typename _T>
struct remove_reference
{
    typedef _T type;
};

template<typename _T>
struct remove_reference<_T&>
{
    typedef _T type;
};

template<typename _T>
struct remove_reference<_T&&>
{
    typedef _T type;
};

template<typename _T>
struct add_lvalue_reference
{
    typedef typename remove_reference<_T>::type& type;
};

template<typename _T>
struct add_rvalue_reference
{
    typedef typename remove_reference<_T>::type&& type;
};

template<typename _T>
struct add_pointer
{
    typedef typename remove_reference<_T>::type* type;
};

template<typename _T>
struct remove_pointer
{
    typedef _T type;
};

template<typename _T>
struct remove_pointer<_T*>
{
    typedef _T type;
};

template<typename _T>
struct remove_pointer<_T* const>
{
    typedef _T type;
};

template<typename _T>
struct remove_pointer<_T* volatile>
{
    typedef _T type;
};

template<typename _T>
struct remove_pointer<_T* const volatile>
{
    typedef _T type;
};

template<typename _T>
struct remove_extent
{
    typedef _T type;
};

template<typename _T>
struct remove_extent<_T[]>
{
    typedef _T type;
};

template<typename _T, size_t _N>
struct remove_extent<_T[_N]>
{
    typedef _T type;
};

template<typename _T>
struct remove_all_extents
{
    typedef _T type;
};

template<typename _T>
struct remove_all_extents<_T[]>
  : remove_all_extents<_T>
{};

template<typename _T, size_t _N>
struct remove_all_extents<_T[_N]>
  : remove_all_extents<_T>
{};

template<typename _T>
struct make_signed
{
    typedef _T type;
};

template<>
struct make_signed<bool>;

template<>
struct make_signed<char>
{
    typedef signed char type;
};

template<>
struct make_signed<unsigned char>
{
    typedef signed char type;
};

template<>
struct make_signed<unsigned short>
{
    typedef short type;
};

template<>
struct make_signed<unsigned>
{
    typedef int type;
};

template<>
struct make_signed<unsigned long>
{
    typedef long type;
};

template<>
struct make_signed<unsigned long long>
{
    typedef long long type;
};

template<typename _T>
struct make_unsigned
{
    typedef _T type;
};

template<>
struct make_unsigned<char>
{
    typedef unsigned char type;
};

template<>
struct make_unsigned<signed char>
{
    typedef unsigned char type;
};

template<>
struct make_unsigned<short>
{
    typedef unsigned short type;
};

template<>
struct make_unsigned<int>
{
    typedef unsigned type;
};

template<>
struct make_unsigned<long>
{
    typedef unsigned long type;
};

template<>
struct make_unsigned<long long>
{
    typedef unsigned long long type;
};

#ifdef __SIZEOF_INT128__
template<>
struct make_signed<unsigned __int128>
{
    typedef __int128 type;
};

template<>
struct make_unsigned<__int128>
{
    typedef unsigned __int128 type;
};
#endif

//////////////////////////// Type identity /////////////////////////////

template<typename, typename>
struct is_same
  : false_type
{};

template<typename _T>
struct is_same<_T, _T>
  : true_type
{};

template<typename _T>
typename add_rvalue_reference<_T>::type declval() noexcept;

///////////////////////// Type classification //////////////////////////

template<typename _T>
struct is_void
  : is_same<typename remove_cv<_T>::type, void>
{};

template<typename _T>
struct is_integral
  : integral_constant<bool, !is_same<typename make_signed<_T>::type, typename make_unsigned<_T>::type>::value>
{};

template<>
struct is_integral<bool>
  : true_type
{};

template<typename>
struct is_floating_point
  : false_type
{};

template<>
struct is_floating_point<float>
  : true_type
{};

template<>
struct is_floating_point<double>
  : true_type
{};

template<>
struct is_floating_point<long double>
  : true_type
{};

template<typename>
struct is_array
  : false_type
{};

template<typename _T>
struct is_array<_T[]>
  : true_type
{};

template<typename _T, size_t _N>
struct is_array<_T[_N]>
  : true_type
{};

template<typename _T>
struct is_enum
  : integral_constant<bool, __is_enum(_T)>
{};

template<typename _T>
struct is_union
  : integral_constant<bool, __is_union(_T)>
{};

template<typename _T>
struct is_class
  : integral_constant<bool, __is_class(_T)>
{};

template<typename>
struct __is_function_helper
  : false_type
{};

template<typename _R, typename..._Args>
struct __is_function_helper<_R(_Args...)>
  : true_type
{};

template<typename _R, typename..._Args>
struct __is_function_helper<_R(_Args..., ...)>
  : true_type
{};

template<typename _T>
struct is_function
  : __is_function_helper<typename remove_cv<typename remove_reference<_T>::type>::type>
{};

template<typename>
struct is_lvalue_reference
  : false_type
{};

template<typename _T>
struct is_lvalue_reference<_T&>
  : true_type
{};

template<typename>
struct is_rvalue_reference
  : false_type
{};

template<typename _T>
struct is_rvalue_reference<_T&&>
  : true_type
{};

template<typename>
struct is_reference
  : false_type
{};

template<typename _T>
struct is_reference<_T&>
  : true_type
{};

template<typename _T>
struct is_reference<_T&&>
  : true_type
{};

template<typename>
struct is_pointer
  : false_type
{};

template<typename _T>
struct is_pointer<_T*>
  : true_type
{};

template<typename _T>
struct is_pointer<_T* const>
  : true_type
{};

template<typename _T>
struct is_pointer<_T* volatile>
  : true_type
{};

template<typename _T>
struct is_pointer<_T* const volatile>
  : true_type
{};

template<typename>
struct is_member_pointer
  : false_type
{};

template<typename _T, class _U>
struct is_member_pointer<_T _U::*>
  : true_type
{};

template<typename _T, class _U>
struct is_member_pointer<_T _U::* const>
  : true_type
{};

template<typename _T, class _U>
struct is_member_pointer<_T _U::* volatile>
  : true_type
{};

template<typename _T, class _U>
struct is_member_pointer<_T _U::* const volatile>
  : true_type
{};

template<typename _T>
struct is_member_function_pointer
  : integral_constant<bool, is_member_pointer<_T>::value && is_function<_T>::value>
{};

template<typename _T>
struct is_member_object_pointer
  : integral_constant<bool, is_member_pointer<_T>::value && !is_function<_T>::value>
{};

template<typename _T>
struct is_arithmetic
  : integral_constant<bool, is_integral<_T>::value || is_floating_point<_T>::value>
{};

template<typename _T>
struct is_fundamental
  : integral_constant<bool, is_arithmetic<_T>::value || is_void<_T>::value>
{};

template<>
struct is_fundamental<decltype(nullptr)>
  : true_type
{};

template<>
struct is_fundamental<const decltype(nullptr)>
  : true_type
{};

template<>
struct is_fundamental<volatile decltype(nullptr)>
  : true_type
{};

template<>
struct is_fundamental<const volatile decltype(nullptr)>
  : true_type
{};

template<typename _T>
struct is_scalar
  : integral_constant<bool,
        is_arithmetic<_T>::value || is_enum<_T>::value ||
        is_pointer<_T>::value || is_member_pointer<_T>::value>
{};

template<>
struct is_scalar<decltype(nullptr)>
  : true_type
{};

template<>
struct is_scalar<const decltype(nullptr)>
  : true_type
{};

template<>
struct is_scalar<volatile decltype(nullptr)>
  : true_type
{};

template<>
struct is_scalar<const volatile decltype(nullptr)>
  : true_type
{};

template<typename _T>
struct is_object
  : integral_constant<bool, !(is_void<_T>::value || is_function<_T>::value || is_reference<_T>::value)>
{};

template<typename _T>
struct is_compound
  : integral_constant<bool, !is_fundamental<_T>::value>
{};

template<typename>
struct is_const
  : false_type
{};

template<typename _T>
struct is_const<const _T>
  : true_type
{};

template<typename>
struct is_volatile
  : false_type
{};

template<typename _T>
struct is_volatile<volatile _T>
  : true_type
{};

template<typename _T>
struct is_trivial
  : integral_constant<bool, __is_trivial(_T)>
{};

template<typename _T>
struct is_trivially_copyable
  : integral_constant<bool, __is_trivially_copyable(_T)>
{};

template<typename _T>
struct is_standard_layout
  : integral_constant<bool, __is_standard_layout(_T)>
{};

template<typename _T>
struct is_pod
  : integral_constant<bool, __is_pod(_T)>
{};

template<typename _T>
struct is_literal_type
  : integral_constant<bool, __is_literal_type(_T)>
{};

template<typename _T>
struct is_empty
  : integral_constant<bool, __is_empty(_T)>
{};

template<typename _T>
struct is_polymorphic
  : integral_constant<bool, __is_polymorphic(_T)>
{};

template<typename _T>
struct is_abstract
  : integral_constant<bool, __is_abstract(_T)>
{};

template<typename _T, bool = is_arithmetic<_T>::value>
struct __is_signed_helper
  : false_type
{};

template<typename _T>
struct __is_signed_helper<_T, true>
  : integral_constant<bool, _T(-1) < _T(0)>
{};

template<typename _T>
struct is_signed
  : __is_signed_helper<_T>
{};

template<typename _T, bool = is_arithmetic<_T>::value>
struct __is_unsigned_helper
  : false_type
{};

template<typename _T>
struct __is_unsigned_helper<_T, true>
  : integral_constant<bool, _T(0) < _T(-1)>
{};

template<typename _T>
struct is_unsigned
  : __is_unsigned_helper<_T>
{};

////////////////////////// Special operations //////////////////////////

template<typename _Base, typename _Derived>
struct is_base_of
  : integral_constant<bool, __is_base_of(_Base, _Derived)>
{};

template<typename _From, typename _To, bool = is_void<_From>::value || is_function<_To>::value || is_array<_To>::value>
struct __is_convertible_helper
  : is_void<_To>
{};

template<typename _From, typename _To>
struct __is_convertible_helper<_From, _To, false>
{
  private:
    template<typename _T> static void __convert(_T);

    template<typename _T, typename = decltype(__convert<_T>(declval<_From>()))>
    static true_type __test(_From);

    template<typename>
    static false_type __test(...);

  public:
    typedef decltype(__test<_To>(declval<_From>())) type;
};

template<typename _From, typename _To>
struct is_convertible
  : __is_convertible_helper<_From, _To>::type
{};

template<typename _T, typename..._Args>
struct is_trivially_constructible
  : integral_constant<bool, __is_trivially_constructible(_T, _Args...)>
{};

template<typename _T, typename..._Args>
struct is_trivially_default_constructible
  : is_trivially_constructible<_T>
{};

//////////////////////////// Miscellaneous /////////////////////////////

template<size_t _Length, size_t _Alignment>
struct aligned_storage
{
    class type { alignas(_Alignment) unsigned char __data[_Length]; };
};

template<typename..._Types>
struct __aligned_union_helper
{
    static constexpr size_t alignment_value = 0;
    class type {};
};

template<typename _T, typename..._Rest>
struct __aligned_union_helper<_T, _Rest...>
{
  private:
    typedef __aligned_union_helper<_Rest...> _R;

  public:
    static constexpr size_t alignment_value = alignof(_T) > _R::alignment_value ? alignof(_T) : _R::alignment_value;
    class type { alignas(alignment_value) char _data[sizeof(_T) > sizeof(_R::type) ? sizeof(_T) : sizeof(_R::type)]; };
};

template<size_t _Length, typename..._Types>
struct aligned_union
  : __aligned_union_helper<char[_Length], _Types...>
{};

template<typename..._Types>
struct aligned_union<0, _Types...>
  : __aligned_union_helper<_Types...>
{};

template<typename _T>
class decay
{
  private:
    typedef typename remove_reference<_T>::type _U;

  public:
    typedef typename conditional<
        is_array<_U>::value,
        typename remove_extent<_U>::type*,
        typename conditional<
            is_function<_U>::value,
            typename add_pointer<_U>::type,
            typename remove_cv<_U>::type
        >::type
    >::type type;
};

template<typename...>
using __void_t = void;

template<typename..._T>
struct common_type
{};

template<typename _T>
struct common_type<_T>
  : common_type<_T, _T>
{};

template<typename, typename, typename = void>
struct __common_type_binary
{};

template<typename _T, typename _U>
struct __common_type_binary<_T, _U, __void_t<decltype(true ? declval<_T>() : declval<_U>())>>
{
    typedef typename decay<decltype(true ? declval<_T>() : declval<_U>())>::type type;
};

template<typename _T, typename _U>
struct common_type<_T, _U>
  : __common_type_binary<typename decay<_T>::type, typename decay<_U>::type>
{};

template<typename, typename = void>
struct __common_type_multiary
{};

template<typename _T, typename _U, typename..._V>
struct __common_type_multiary<common_type<_T, _U, _V...>, __void_t<typename common_type<_T, _U>::type>>
  : common_type<typename common_type<_T, _U>::type, _V...>
{};

template<typename _T, typename _U, typename..._V>
struct common_type<_T, _U, _V...>
  : __common_type_multiary<common_type<_T, _U, _V...>>
{};

template<typename _T>
struct underlying_type
{
    typedef __underlying_type(_T) type;
};

} // namespace std

#endif // <type_traits>

// vim: ft=cpp
