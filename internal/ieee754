// This file is part of Metallic, a runtime library for WebAssembly.
//
// Copyright (C) 2017 Chen-Pang He <chen.pang.he@jdh8.org>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/

#ifndef METALLIC_INTERNAL_IEEE754
#define METALLIC_INTERNAL_IEEE754

#include "integer"
#include <limits>
#include <type_traits>
#include <cstdint>

namespace std {
namespace __internal {
/*!
 * \brief Manipulation of unsigned IEEE-754 floats
 *
 * Entities in this namespace work on IEEE-754 floating-point numbers
 * and their representations whose signbits are assumed to be clear.
 * Violation of the aformentioned rule would result in inaccurate results.
 * The range of std::abs is the domain in this namespace.
 *
 * Bit-pattern results may be negative though.
 *
 * \sa magnitude::normalize on how negative integers
 *     represent subnormal numbers
 */
namespace magnitude {
/*!
 * \brief Normalize nonzero magnitude
 *
 * Notation of subnormal numbers is a space-saving technique in IEEE 754.
 * However, processing subnormal numbers requires an extra step to get correct
 * exponents and significands.  This function provides that step.
 *
 * The signbits of results safely join exponent bits because negative
 * representations were unused.  Infinite and normal numbers remain intact
 * since exponent bias is preserved.  The exponent representation of a
 * subnormal number becomes 0 or negative to preserve exponent bias.
 *
 * Zero is excluded from the domain of this function because one half of the
 * smallest normal number is already mapped to 0 and there is no other suitable
 * result for 0.
 *
 * \param i - Representation of a nonzero magnitude
 * \return  Normalized magnitude
 */
template<typename Float, typename Representation>
Representation normalize(Representation i)
{
    static_assert(sizeof(Float) == sizeof(Representation), "Representation must have the same size as Float");
    static_assert(Representation(-1) < 0, "Representation must be signed integer");

    const int SignificandBits = numeric_limits<Float>::digits - 1;
    const int MagnitudeBits = numeric_limits<Representation>::digits;

    typename std::make_unsigned<Representation>::type j = i;

    if (i < Representation(1) << SignificandBits) {
        Representation shift = clz(j) - (MagnitudeBits - SignificandBits);
        return (i << shift) - (shift << SignificandBits);
    }
    return i;
}

/*!
 * \brief Normalize nonzero \c float magnitude
 *
 * This function simply calls normalize<float> in order to omit template
 * parameter.
 *
 * \param i - Representation of a nonzero \c float magnitude
 * \return  Normalized magnitude
 */
inline std::int32_t normalize(std::int32_t i)
{
    return normalize<float>(i);
}

/*!
 * \brief Normalize nonzero \c double magnitude
 *
 * This function simply calls normalize<double> in order to omit template
 * parameter.
 *
 * \param i - Representation of a nonzero \c double magnitude
 * \return  Normalized magnitude
 */
inline std::int64_t normalize(std::int64_t i)
{
    return normalize<double>(i);
}

} // namespace magnitude
} // namespace __internal
} // namespace std

#endif

// vim: ft=cpp
