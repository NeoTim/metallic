// This file is part of Metallic, a runtime library for WebAssembly.
//
// Copyright (C) 2017 Chen-Pang He <chen.pang.he@jdh8.org>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/

#ifndef METALLIC_INTERNAL_IEEE754
#define METALLIC_INTERNAL_IEEE754

#include "integer"
#include <cstdint>

namespace std {
namespace __internal {
/*!
 * \brief Manipulation of unsigned IEEE-754 floats
 *
 * Entities in this namespace work on IEEE-754 floating-point numbers
 * and their representations whose signbits are assumed to be clear.
 * Violation of the aformentioned rule would result in inaccurate results.
 * The range of std::abs is the domain in this namespace.
 *
 * Bit-pattern results may be negative though.
 *
 * \sa magnitude::normalize(std::int32_t) on how negative integers
 *     represent subnormal numbers
 */
namespace magnitude {
/*!
 * \brief Normalize nonzero \c float magnitude
 *
 * Notation of subnormal numbers is a space-saving technique in IEEE 754.
 * However, processing subnormal numbers requires an extra step to get correct
 * exponents and significands.  This function provides that step.
 *
 * The signbits of results safely join exponent bits because negative
 * representations were unused.  Infinite and normal numbers remain intact
 * since exponent bias is preserved.  The exponent representation of a
 * subnormal number becomes 0 or negative to preserve exponent bias.
 *
 * Zero is excluded from the domain of this function because 0x00400000 is
 * already mapped to 0 and there is no other suitable result for 0.
 *
 * \param i - Representation of a nonzero \c float magnitude
 * \return  Normalized magnitude
 */
inline std::int32_t normalize(std::int32_t i)
{
    if (i < 0x00800000) {
        std::int32_t shift = clz(i) - 8;
        return (i << shift) - (shift << 23);
    }
    return i;
}

/*!
 * \brief Normalize nonzero \c double magnitude
 *
 * Zero is excluded from the domain of this function because 0x0008000000000000
 * is already mapped to 0 and there is no other suitable result for 0.
 *
 * \sa normalize(std::int32_t) on other details
 *
 * \param i - Representation of a nonzero \c double magnitude
 * \return  Normalized magnitude
 */
inline std::int64_t normalize(std::int64_t i)
{
    if (i < 0x0010000000000000) {
        std::int64_t shift = clz(i) - 11;
        return (i << shift) - (shift << 52);
    }
    return i;
}

} // namespace magnitude
} // namespace __internal
} // namespace std

#endif

// vim: ft=cpp
